= Dokumentation Linux LF10b
:toc:

== Kommandos

Aufbau von Kommandos:

 kommando [-option]... [argument]...

- (Kurz-) Optionen werden von einem einfachen Minuszeichen eingeleitet und bestehen aus einem einzelnen Buchstaben
- mehrere Optionen können (in der Regel in beliebiger Reihenfolge) nach einem einzelnen Minuszeichen stehen
- Optionen geben an, *wie* sich ein Kommando verhält
- abhängig vom Kommando können (mehrere) Argumente übergeben werden
- Argumente geben an, *worauf* sich ein Kommando bezieht
- es kann auch Optionen geben, die direkt ein Argument verlangen. Dies wird direkt hinter die Kurzoption geschrieben (ohne Gleichheitszeichen `=`). Bei Verwendung der Langoption (zwei Minuszeichen) erfolgt die Zuweisung in der Regel mit einem Gleichheitszeichen. 

Beispiel `tar`:

 tar -f /path/to/file
 tar --file=/path/to/file

- es gibt zwei Arten von Kommandos: *intern* und *extern* realisierte. 
  - *intern* realisierte Kommandos werden von der Shell (z.B. `BASH`) direkt bereitgestellt
  - *extern* realisierte Kommandos sind zusätzlich als eigene Pakete installiert

== Grundlegende Kommandos

- `whoami` angemeldeten Benutzer anzeigen
- `pwd` aktuelles Verzeichnis ausgeben
- `mkdir <verzeichnis>` Verzeichnis anlegen
- `ls` Verzeichnisinhalt anzeigen
  - `ls -a` auch versteckte Dateien (welche mit einem Punkt beginnen anzeigen)
  - `ls -lah` detaillierte Informationen, versteckte Dateien und Grössen in menschenlesbarere Form (KiB, MiB, GiB ...)
- `cd <verzeichnis>` ins Verzeichnis `<verzeichnis>` wechseln
- `cd` ins Heimatverzeichnis wechseln
- `cd ~` ins Heimatverzeichnis wechseln
- `cd /home/<user>` ins Heimatverzeichnis wechseln
- `cd -` ins vorherige Verzeichnis wechseln
- `cd ..` ins übergeordnete Verzeichnis wechseln
- Pfadangaben:
  - *absolut* vollständiger Pfad, immer beginnend mit dem Wurzelverzeihnis (`/`)
  - *relativ* ausgehend vom aktuellen Verzeichnis, beginnt *nie* mit einem Slash (`/`)
- `touch <datei>` kann verwendet werden, um leere Dateien zu erstellen
- `clear` Bildschirminhalt leeren (Tastenkombination `STRG+L`)
- `date` aktuelles Datum und Uhrzeit ausgeben, Ausgabe kann formatiert werden, z.B. `date "+%d.%m.%Y"` -> `19.09.2023`
- `history` Anzeige der zuletzt eingegebenen Kommandos
- `cat <file>` gibt den Inhalt von `<file>` auf der Konsole aus
- `less <file>` gibt den Inhalt von `<file>` im Pager `less` aus. So können wir in der Datei scrollen, suchen usw.

== Hilfe auf der Kommandozeile

- die Kurzhilfe zu einem Kommando kann (in der Regel) über die Option `--help` (manchmal auch `-h`) aufgerufen werden
- eine ausführliche Hilfe bieten die Manpages, aufrufbar duch das Kommando `man <kommando>`
- intern realisierte Kommandos haben keine eigene Manpage. Hilfe dazu erhält man mittels `help <kommando>` bzw. sind diese in der Manpage der `BASH` enthalten- bei der Angabe vom Kommandos und Pfaden sollte immer die Autovervollständigung (mittels TAB-Taste) genutzt werden
- alle eingegebenen Kommandos werden in der `history` gespeichert. Über die Pfeltasten können ältere Kommandos aufgerufen werden
- mit der _History Expansion_ kann einfach auf in der Vergangenheit eingegebene Kommandos zugegriffen werden: `!107` führt das Kommando mit dem Index `107` erneut aus. Weiteres siehe `man history`

== Tastenkombinationen

- `STRG+L` Kommando `clear`
- `STRG+C` sendet Signal `SIGINT` an Kommando (ähnlich wie _Abbrechen_)

== Grundlegende Dateioperationen

- `cp <quelle> <ziel>`: kopiert `<quelle>` nach `<ziel>`. Sowohl `<quelle>` als auch `<ziel>` können reguläre Dateien oder Verzeichnisse sein. 
  - ist `<ziel>` eine Datei die nicht existiert, wird diese erstellt, existiert die Datei wird sie (ohne Nachfrage) überschrieben
  - ist `<ziel>` ein Verzeichnis, wird die Datei hineinkopiert, eine beretis vorhandene Datei würde auch überschrieben werden
  - ist `<quelle>` ein Verzeichnis, so müssen wird die Option `-r` (rekursiv) verwenden: `cp -r mydir/ another_dir/`
- `mv <quelle> <ziel>` verschiebt `<quelle>` nach `<ziel>`. Sowohl `<quelle>` als auch `<ziel>` können reguläre Dateien oder Verzeichnisse sein.
  - bei `mv` gibt es keine Option `-r`, da wir hier nicht rekursiv vorgehen müssen. Siehe Screenshot:

image::../screenshots/cp_und_mv.png[cp_und_mv, 800]

- `rm <datei>` löscht `<datei>` ohne Nachfrage
- `rm -r <verzeichnis>` löscht `<verzeichnis>` mit Inhalt ohne Nachfrage
- `rmdir <verzeichnis>` löscht `<verzeichnis>`, aber nur, wenn es leer ist
- Option `-i` gilt für `cp`, `mv` und `rm`: Nachfrage, falls Ziel überschrieben oder gelöscht werden soll

== Wildcards / Globbing Characters

- `*` (Asterisk) steht für ein beliebiges Zeichen, das beliebig oft vorkommen darf
- `?` steht für ein beliebiges Zeichen, das exakt einmal vorkommen darf
- Beispiele: 
  - `ls *.txt` listet alle Textdateien
  - `rm file*` löscht alle Dateien, die mit `file` beginnen
  - `rm -r *` löscht alle Dateien und Verzeichnisse im aktuellen Verzeichnis (unwideruflich - Gefahr!)

== Variablen

- es gibt zwei Arten von Variablen: 
  - _Systemvariablen_/_Umgebungsvariablen_: Diese sind systemweit in jeder Shell existent und gültig und werden nach Konvention komplett in Großbuchstaben gescchrieben
  - _Shellvariablen_: gelten nur für die Shell, in der sie definiert wurden. Werden nicht automatisch vererbt oder weitergereicht, könenn aber exportiert werden. Dann sind sie auch in Subshells gültig. Werden nach Konvention in Kleinbuchstaben geschrieben
  - Beispiele:
    - `foo=bar` Erstelle die Variable `foo` und weise ihr den Wert `bar` zu
    - `echo $HOME` Zeige den Inhalt der Umgebungsvariabel `HOME` an
    - `echo $foo` Zeige den Inhalt der Shellvariable `foo` an
    - `export foo` Mache `foo` auch in Subshells verfügbar
- wollen wir eigenen Variablen definieren, die systemweit auch über einen Neustart hinaus gültig sind, so müssen wir diese in einer geeignetetn Datei definieren

== Aliase

Mit Aliasen können Kommandos, Pfadangaben usw. "abgekürzt" werden. Beispiele:

 alias ll='ls -l'
 alias df='df -h'

Wird der Alias auf der Kommandozeile erstellt, ist er nur für diese eine Shell gültig. Sollen Aliase systemweit und über einen Neustart hinaus gültig sein, so müssen diese in einer Datei (z.B. `~/.bashrc` oder `~/.bash_aliases` definiert werden.

== Umleitungen und Redirects

=== UNIX Philosopie

- Schreibe Programme so, dass sie nur *eine* Aufgabe erledigen und diese gut machen
- Schreibe Programme so, dass sie zusammenarbeiten
- Schreibe Programme so, dass sie Textströme verwenden, denn das ist eine universelle Schnittstelle

=== Kanäle

- `stdin` Standardeingabekanal - `0`
- `stdout` Standardausgabekanal - `1`
- `sterr` Standardfehlerkanal - `2`

=== Redirects

Mit Redirects lassen sich obige Kanäle in *Dateien* umleiten:

- `>` einfacher Redirect: Ausgabekanäle können in eine *Datei* umgeleitet werden. Achtung: Inhalt wird überschrieben
- `>>` doppelter Redirect: Ausgabekanäle können in eine *Datei* umgeleitet werden. Inhalt wird nicht überschrieben, Ausgabe wird angehängt

=== Umleitungen (mit der Pipe |)

Mit der Pipe (`|`) können wir den Ausgabekanal eines Kommandos in den Eingabekanal eines anderen Kommandos umleiten:

 kommando1 | kommando2

 ls /etc | less

Leitet die Ausgabe von `ls` in den Pager `less` um


Redirects und Umleitungen können kombiniert werden. Oft werden sog. Komandopipelines erstellt, d.h. eine Kombination aus meheren Umleitungen. Beispiel:

 grep -wr alias ~ | grep -v \# | grep -v _history | grep -v txt | cut -d: -f2

Mit obigem Kommando lassen wir uns alle Aliasdefinitionen in unserem Heimatverzeichnis ausgeben, eliminieren aber alle Kommentare usw. von der Ausgabe.

== Kommandosubstitution

Ähnlich wie die _Variablensubstitution_, nur dass das Kommando durch seine Standardausgabe ersetzt wird. Nützlich z.B. wenn wir die Ausgabe eines Kommandos in einer Variablen speichern wollen.

Beispiel:

 cur_date_time=$(date "+%d.%m.%Y, %H:%M.")

Es gibt zwei Syntaxen:

 $(kommando) 
 `kommando`

In beiden Fällen wird das Kommando in einer Subshell ausgeführt. Kommandosubstitutionen können auch verschachtelt sein.

